import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { Prisma, PrismaClient } from '@<%= npmScope %>/api/prisma'
import { ConfigService } from '@<%= npmScope %>/api/config'
import { CorePagingInput } from './dto/core-paging.input'

@Injectable()
export class ApiCoreDataAccessService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  constructor(private readonly configService: ConfigService) {
    const config: Prisma.PrismaClientOptions = {
      datasources: {
        db: { url: `${process.env['DATABASE_URL']}?connection_limit=30` },
      },
      log:
        process.env['LOG_PRISMA_QUERIES'] === 'true' ||
        process.env['COUNT_PRISMA_QUERIES'] === 'true'
          ? [{ emit: 'event', level: 'query' }]
          : [{ emit: 'event', level: 'warn' }],
    }

    // Must call super first before accessing this
    super(config)
    this.queryCount = 0

    // Check for Prisma Optimize setup using config service
    const optimizeEnabled = configService.prismaOptimizeEnabled
    const optimizeApiKey = configService.prismaOptimizeApiKey

    if (optimizeEnabled && optimizeApiKey) {
      console.log('üöÄ Prisma Optimize enabled with API key')
      const { withOptimize } = require('@prisma/extension-optimize')
      const extendedClient = new PrismaClient(config).$extends(
        withOptimize({ apiKey: optimizeApiKey })
      )
      Object.assign(this, extendedClient)
    } else {
      if (optimizeEnabled && !optimizeApiKey) {
        console.warn('‚ö†Ô∏è  OPTIMIZE_ENABLED is true but OPTIMIZE_API_KEY is not set')
      }
    }
  }

  public queryCount: number

  public async onModuleDestroy(): Promise<void> {
    await this.$disconnect()
  }

  public async onModuleInit(): Promise<void> {
    await this.$connect()

    if (process.env['LOG_PRISMA_QUERIES'] == 'true') {
      this.$on('query' as never, async (e: Prisma.QueryEvent) => {
        console.log(`QUERY: ${e.query} \n\nPARAMS: ${e.params}\n\n\n`)
      })
    }

    if (process.env['COUNT_PRISMA_QUERIES'] == 'true') {
      this.$on('query' as never, async () => {
        this.queryCount++
      })
    }
  }

  filter<T extends Record<string, unknown>>(
    input: CorePagingInput = {},
  ): {
    skip: number
    take: number
    where?: T
    orderBy: { [key: string]: 'asc' | 'desc' }
  } {
    const {
      search = '',
      searchFields = [],
      take = 20,
      skip = 0,
      orderBy = 'id',
      orderDirection = 'asc',
      filters = {},
    } = input

    const trimmedSearch = search.trim()
    const andConditions: unknown[] = []

    if (Object.keys(filters).length > 0) {
      andConditions.push(filters)
    }

    if (trimmedSearch && searchFields.length > 0) {
      const terms = trimmedSearch.includes(' ')
        ? trimmedSearch.split(' ')
        : [trimmedSearch].filter(Boolean)
      const searchFilters = terms.map(term => ({
        OR: searchFields.map(field => ({
          [field]: { contains: term, mode: Prisma.QueryMode.insensitive },
        })),
      }))
      andConditions.push(...searchFilters)
    }

    const where = andConditions.length > 0 ? { AND: andConditions } : undefined

    return {
      skip,
      take,
      where: where as unknown as T, // assert type safety for the generic
      orderBy: { [orderBy]: orderDirection },
    }
  }
}

