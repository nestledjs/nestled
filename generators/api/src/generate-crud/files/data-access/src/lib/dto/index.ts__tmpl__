<%# EJS template for generating DTOs %>
<%
let gqlImports = new Set(['Field', 'InputType'])
let usesGraphQLJSON = false
let usesInt = false
let usesFloat = false
let usesID = false
let enumNames = new Set()
let usesPartialType = false
const alwaysOptionalFields = ['id', 'createdAt', 'updatedAt']

// Helper function to get relation fields for a model
function getRelationFields(model) {
    return model.fields.filter(field => field.relationName && field.relationName.length > 0)
}

// Helper function to get virtual relation fields for a model
function getVirtualRelationFields(model) {
    const relationFields = getRelationFields(model)
    const virtualFields = []

    relationFields.forEach(relationField => {
        // Only generate virtual fields for relations that don't have explicit foreign keys
        if (!relationField.relationFromFields || relationField.relationFromFields.length === 0) {
            if (relationField.isList) {
                // This is a multi-relation without foreign keys (many-to-many or one-to-many from parent)
                // Generate a virtual foreign key field for connecting
                const virtualFieldName = relationField.name + 'Ids'
                // Check if there's already a scalar field with this name
                const existingField = model.fields.find(f => f.name === virtualFieldName && (!f.relationName || f.relationName.length === 0))
                if (!existingField) {
                    virtualFields.push({
                        name: virtualFieldName,
                        type: 'String',
                        isList: true,
                        isOptional: true,
                        isVirtual: true, // Mark as virtual so we know it's generated
                        relationName: relationField.relationName,
                        relatedField: relationField.name,
                    })
                }
            } else {
                // This is a single relation without foreign keys (one-to-one or one-to-many from parent)
                // Generate a virtual foreign key field for connecting
                const virtualFieldName = relationField.name + 'Id'
                // Check if there's already a scalar field with this name
                const existingField = model.fields.find(f => f.name === virtualFieldName && (!f.relationName || f.relationName.length === 0))
                if (!existingField) {
                    virtualFields.push({
                        name: virtualFieldName,
                        type: 'String',
                        isList: false,
                        isOptional: true,
                        isVirtual: true, // Mark as virtual so we know it's generated
                        relationName: relationField.relationName,
                        relatedField: relationField.name,
                    })
                }
            }
        }
    })

    return virtualFields
}

// First pass to determine necessary imports and enums
for (const model of models) {
    for (const field of model.fields) {
        if (field.relationName && field.relationName.length > 0) continue // Skip relation object fields
        if (field.type === 'Int') usesInt = true
        if (field.type === 'Float' || field.type === 'Decimal') usesFloat = true
        if (field.type === 'Json') usesGraphQLJSON = true
        if (field.type === 'ID') usesID = true
        if (field.kind === 'enum') {
            enumNames.add(field.type)
        }
    }
}

if (usesInt) gqlImports.add('Int')
if (usesFloat) gqlImports.add('Float')
if (usesID) gqlImports.add('ID')
usesPartialType = models.length > 0 // If we generate any Update input, we need PartialType
%>
import { CorePagingInput } from '@<%= npmScope %>/api/core/data-access';

<% for (const model of models) { %>
<%
// Get all regular fields (non-relation) and virtual relation fields
const regularFields = model.fields.filter(field => !field.relationName || field.relationName.length === 0);
const virtualRelationFields = getVirtualRelationFields(model);
const allFields = [...regularFields, ...virtualRelationFields];
%>
@InputType()
export class Create<%= model.modelName %>Input {
<% for (const field of allFields) { %>
  <%
    let baseGqlType;
    let tsType;
    if (field.type === 'String') { baseGqlType = 'String'; tsType = 'string'; }
    else if (field.type === 'Int') { baseGqlType = 'Int'; tsType = 'number'; }
    else if (field.type === 'Float') { baseGqlType = 'Float'; tsType = 'number'; }
    else if (field.type === 'Decimal') { baseGqlType = 'Float'; tsType = 'number'; }
    else if (field.type === 'Boolean') { baseGqlType = 'Boolean'; tsType = 'boolean'; }
    else if (field.type === 'DateTime') { baseGqlType = 'Date'; tsType = 'Date'; }
    else if (field.type === 'Json') { baseGqlType = 'GraphQLJSON'; tsType = 'typeof GraphQLJSON'; }
    else if (field.type === 'ID') { baseGqlType = 'ID'; tsType = 'string'; }
    else if (field.kind === 'enum') {
      baseGqlType = field.type;
      tsType = field.type;
    } else {
      baseGqlType = 'String'; tsType = 'string';
    }
    let fieldDecoratorTypeArg = '';
    let finalTsType = tsType;
    let isOptional = false;
    if (field.isList) {
      fieldDecoratorTypeArg = `() => [${baseGqlType}]`;
      finalTsType = tsType + '[]';
    } else {
      if (baseGqlType !== 'String' && baseGqlType !== 'Boolean') {
        fieldDecoratorTypeArg = `() => ${baseGqlType}`;
      }
    }
    // Always optional for id, createdAt, updatedAt, virtual fields, and relational fields
    if (alwaysOptionalFields.includes(field.name) || field.isVirtual || field.relationName) {
      isOptional = true;
    } else {
      isOptional = field.isOptional;
    }
  %>
  @Field(<% if (fieldDecoratorTypeArg) { %><%- fieldDecoratorTypeArg %>, <% } %>{ nullable: <%= isOptional ? 'true' : 'false' %> })
  <%= field.name %><%= isOptional ? '?' : '!' %>: <%= finalTsType %>
<% } %>
}

@InputType()
export class Update<%= model.modelName %>Input {
<% for (const field of allFields) { %>
  <%
    let baseGqlType;
    let tsType;
    if (field.type === 'String') { baseGqlType = 'String'; tsType = 'string'; }
    else if (field.type === 'Int') { baseGqlType = 'Int'; tsType = 'number'; }
    else if (field.type === 'Float') { baseGqlType = 'Float'; tsType = 'number'; }
    else if (field.type === 'Decimal') { baseGqlType = 'Float'; tsType = 'number'; }
    else if (field.type === 'Boolean') { baseGqlType = 'Boolean'; tsType = 'boolean'; }
    else if (field.type === 'DateTime') { baseGqlType = 'Date'; tsType = 'Date'; }
    else if (field.type === 'Json') { baseGqlType = 'GraphQLJSON'; tsType = 'typeof GraphQLJSON'; }
    else if (field.type === 'ID') { baseGqlType = 'ID'; tsType = 'string'; }
    else if (field.kind === 'enum') {
      baseGqlType = field.type;
      tsType = field.type;
    } else {
      baseGqlType = 'String'; tsType = 'string';
    }
    let fieldDecoratorTypeArg = '';
    let finalTsType = tsType;
    if (field.isList) {
      fieldDecoratorTypeArg = `() => [${baseGqlType}]`;
      finalTsType = tsType + '[]';
    } else {
      if (baseGqlType !== 'String' && baseGqlType !== 'Boolean') {
        fieldDecoratorTypeArg = `() => ${baseGqlType}`;
      }
    }
  %>
  @Field(<% if (fieldDecoratorTypeArg) { %><%- fieldDecoratorTypeArg %>, <% } %>{ nullable: true })
  <%= field.name %>?: <%= finalTsType %>
<% } %>
}

@InputType()
export class List<%= model.modelName %>Input extends CorePagingInput {
<% for (const field of allFields) { %>
  <%
    let baseGqlType;
    let tsType;
    if (field.type === 'String') { baseGqlType = 'String'; tsType = 'string'; }
    else if (field.type === 'Int') { baseGqlType = 'Int'; tsType = 'number'; }
    else if (field.type === 'Float') { baseGqlType = 'Float'; tsType = 'number'; }
    else if (field.type === 'Decimal') { baseGqlType = 'Float'; tsType = 'number'; }
    else if (field.type === 'Boolean') { baseGqlType = 'Boolean'; tsType = 'boolean'; }
    else if (field.type === 'DateTime') { baseGqlType = 'Date'; tsType = 'Date'; }
    else if (field.type === 'Json') { baseGqlType = 'GraphQLJSON'; tsType = 'typeof GraphQLJSON'; }
    else if (field.type === 'ID') { baseGqlType = 'ID'; tsType = 'string'; }
    else if (field.kind === 'enum') {
      baseGqlType = field.type;
      tsType = field.type;
    } else {
      baseGqlType = 'String'; tsType = 'string';
    }
    let fieldDecoratorTypeArg = '';
    let finalTsType = tsType;
    if (field.isList) {
      fieldDecoratorTypeArg = `() => [${baseGqlType}]`;
      finalTsType = tsType + '[]';
    } else {
      if (baseGqlType !== 'String' && baseGqlType !== 'Boolean') {
        fieldDecoratorTypeArg = `() => ${baseGqlType}`;
      }
    }
  %>
  @Field(<% if (fieldDecoratorTypeArg) { %><%- fieldDecoratorTypeArg %>, <% } %>{ nullable: true })
  <%= field.name %>?: <%= finalTsType %>
<% } %>
}

<% } %>
