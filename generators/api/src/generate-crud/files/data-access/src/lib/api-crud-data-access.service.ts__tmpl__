import { Injectable } from '@nestjs/common'
import { ApiCoreDataAccessService } from '@<%= npmScope %>/api/core/data-access'
import { createSelect } from '@<%= npmScope %>/api/core/helpers'
import type { GraphQLResolveInfo } from 'graphql'
import * as dto from './dto'

<% models.forEach((model, idx) => { %>
<% if (!model.modelName || !model.pluralModelName) { throw new Error('EJS template error: modelName or pluralModelName missing for model at index ' + idx + ': ' + JSON.stringify(model)); } %>
<% }) %>

<%
// Helper function to get relation fields for a model
function getRelationFields(model) {
  return model.fields.filter(field => field.relationName && field.relationName.length > 0);
}

// Helper function to get virtual relation fields for a model
function getVirtualRelationFields(model) {
  const relationFields = getRelationFields(model);
  const virtualFields = [];

  relationFields.forEach(relationField => {
    // Only generate virtual fields for relations that don't have explicit foreign keys
    if (!relationField.relationFromFields || relationField.relationFromFields.length === 0) {
      if (relationField.isList) {
        // This is a multi-relation without foreign keys (many-to-many or one-to-many from parent)
        // Generate a virtual foreign key field for connecting
        const virtualFieldName = relationField.name + 'Ids';
        // Check if there's already a scalar field with this name
        const existingField = model.fields.find(f => f.name === virtualFieldName && (!f.relationName || f.relationName.length === 0));
        if (!existingField) {
          virtualFields.push({
            name: virtualFieldName,
            type: 'String',
            isList: true,
            isOptional: true,
            isVirtual: true,
            relationName: relationField.relationName,
            relatedField: relationField.name
          });
        }
      } else {
        // This is a single relation without foreign keys (one-to-one or one-to-many from parent)
        // Generate a virtual foreign key field for connecting
        const virtualFieldName = relationField.name + 'Id';
        // Check if there's already a scalar field with this name
        const existingField = model.fields.find(f => f.name === virtualFieldName && (!f.relationName || f.relationName.length === 0));
        if (!existingField) {
          virtualFields.push({
            name: virtualFieldName,
            type: 'String',
            isList: false,
            isOptional: true,
            isVirtual: true,
            relationName: relationField.relationName,
            relatedField: relationField.name
          });
        }
      }
    }
  });

  return virtualFields;
}

// Helper function to get foreign key fields that need relation handling
function getForeignKeyRelationFields(model) {
  const relationFields = getRelationFields(model);
  const foreignKeyFields = [];

  relationFields.forEach(relationField => {
    if (relationField.relationFromFields && relationField.relationFromFields.length > 0) {
      // This relation has explicit foreign key fields
      relationField.relationFromFields.forEach(fkFieldName => {
        const fkField = model.fields.find(f => f.name === fkFieldName);
        if (fkField) {
          foreignKeyFields.push({
            fieldName: fkFieldName,
            relationName: relationField.name,
            isRequired: !fkField.isOptional
          });
        }
      });
    }
  });

  return foreignKeyFields;
}

// Helper function to generate relation handling code
function generateRelationHandling(model, operation) {
  const virtualRelationFields = getVirtualRelationFields(model);
  const foreignKeyFields = getForeignKeyRelationFields(model);
  const allRelationFields = [...virtualRelationFields, ...foreignKeyFields];

  if (allRelationFields.length === 0) {
    return '    const data = input;';
  }

  let code = '    const { ';
  code += virtualRelationFields.map(field => field.name).join(', ');
  if (foreignKeyFields.length > 0) {
    if (virtualRelationFields.length > 0) code += ', ';
    code += foreignKeyFields.map(field => field.fieldName).join(', ');
  }
  code += ', ...regularFields } = input;\n';
  code += '    const data: any = regularFields;\n\n';

  // Create relation mapping object
  code += '    const connectFields = {\n';
  
  // Add virtual relation fields to the mapping
  virtualRelationFields.forEach(field => {
    if (field.isList) {
      code += `      ${field.relatedField}: ${field.name},\n`;
    } else {
      code += `      ${field.relatedField}: ${field.name},\n`;
    }
  });
  
  // Add foreign key fields to the mapping
  foreignKeyFields.forEach(field => {
    code += `      ${field.relationName}: ${field.fieldName},\n`;
  });
  
  code += '    };\n\n';

  // Generate the iteration logic
  code += '    for (const [key, ids] of Object.entries(connectFields)) {\n';
  code += '      if (ids) {\n';
  
  // Handle different connection types based on operation and field type
  const hasListFields = virtualRelationFields.some(field => field.isList);
  const hasSingleFields = virtualRelationFields.some(field => !field.isList) || foreignKeyFields.length > 0;
  
  if (hasListFields && hasSingleFields) {
    // Mixed field types - need to check if it's an array
    code += '        if (Array.isArray(ids)) {\n';
    code += `          data[key] = { ${operation === 'create' ? 'connect' : 'set'}: ids.map(id => ({ id })) };\n`;
    code += '        } else {\n';
    code += `          data[key] = { ${operation === 'create' ? 'connect' : 'set'}: { id: ids } };\n`;
    code += '        }\n';
  } else if (hasListFields) {
    // Only list fields
    code += `        data[key] = { ${operation === 'create' ? 'connect' : 'set'}: ids.map(id => ({ id })) };\n`;
  } else {
    // Only single fields
    code += `        data[key] = { ${operation === 'create' ? 'connect' : 'set'}: { id: ids } };\n`;
  }
  
  code += '      }\n';
  code += '    }\n';

  return code;
}
%>

@Injectable()
export class ApiCrudDataAccessService {
  constructor(private readonly data: ApiCoreDataAccessService) {}

<% for (const model of models) { %>
  async create<%= model.modelName.charAt(0).toUpperCase() + model.modelName.slice(1) %>(info: GraphQLResolveInfo, input: dto.Create<%= model.modelName %>Input) {
<%- generateRelationHandling(model, 'create') %>

    return this.data['<%= model.modelPropertyName %>'].create({
      data,
      select: createSelect(info),
    });
  }

  async <%= (model.pluralModelName === model.modelName ? model.pluralModelName + 'List' : model.pluralModelName).charAt(0).toLowerCase() + (model.pluralModelName === model.modelName ? model.pluralModelName + 'List' : model.pluralModelName).slice(1) %>(info: GraphQLResolveInfo, input?: dto.List<%= model.modelName %>Input) {
    return this.data['<%= model.modelPropertyName %>'].findMany({
      ...this.data.filter(input),
      select: createSelect(info),
    });
  }

  async <%= (model.pluralModelName === model.modelName ? model.pluralModelName + 'List' : model.pluralModelName).charAt(0).toLowerCase() + (model.pluralModelName === model.modelName ? model.pluralModelName + 'List' : model.pluralModelName).slice(1) %>Count(input?: dto.List<%= model.modelName %>Input) {
    const total = await this.data['<%= model.modelPropertyName %>'].count()
    const count = await this.data['<%= model.modelPropertyName %>'].count({
      ...this.data.filter(input)
    });
    const take = input?.take || 10
    const skip = input?.skip || 0
    const page = Math.floor(skip / take)
     return {
      take,
      skip,
      page,
      count,
      total,
    }
  }

  async <%= model.modelName.charAt(0).toLowerCase() + model.modelName.slice(1) %>(info: GraphQLResolveInfo, id: string) {
    return this.data['<%= model.modelPropertyName %>'].findUnique({
      where: { id },
      select: createSelect(info),
    });
  }

  async update<%= model.modelName.charAt(0).toUpperCase() + model.modelName.slice(1) %>(info: GraphQLResolveInfo, id: string, input: dto.Update<%= model.modelName %>Input) {
<%- generateRelationHandling(model, 'update') %>

    return this.data['<%= model.modelPropertyName %>'].update({
      where: { id },
      data,
      select: createSelect(info),
    });
  }

  async delete<%= model.modelName.charAt(0).toUpperCase() + model.modelName.slice(1) %>(id: string) {
    return this.data['<%= model.modelPropertyName %>'].delete({
      where: { id }
    });
  }
<% } %>
}
