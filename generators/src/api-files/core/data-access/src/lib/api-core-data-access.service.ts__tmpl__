import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { PassportStrategy } from '@nestjs/passport'
import { Strategy } from 'passport-jwt'
import { PrismaClient, Prisma, UserRole } from '../generated'
import { CorePaging } from './models/core-paging'
import { CorePagingInput } from './dto/core-paging.input'

@Injectable()
export class ApiCoreDataAccessService
  extends PrismaClient
  implements OnModuleDestroy, OnModuleInit
{
  constructor() {
    super()
  }

  public async onModuleDestroy() {
    await this.$disconnect()
  }

  public async onModuleInit() {
    await this.$connect()
  }

  async findUserById(id: string) {
    return this.user.findUnique({ where: { id } })
  }

  async findUserByEmail(email: string) {
    const emailRecord = await this.email.findUnique({
      where: { email },
      include: { user: true }
    })
    return emailRecord?.user
  }

  async findUserByDisplayName(displayName: string) {
    return this.user.findFirst({ 
      where: { 
        displayName: {
          equals: displayName,
          mode: Prisma.QueryMode.insensitive
        }
      } 
    })
  }

  async ensureAdminUser(adminId: string): Promise<boolean> {
    const user = await this.findUserById(adminId)
    if (!user || user.role !== UserRole.ADMIN) {
      throw new Error('Not authorized')
    }
    return true
  }

  async displayNameDenyList(displayName: string): Promise<boolean> {
    // Add any display name deny list logic here
    const denyList = ['admin', 'root', 'system']
    return denyList.includes(displayName.toLowerCase())
  }

  search<T extends Record<string, any>>(
    conditions: Prisma.Enumerable<T>[], 
    searchQuery: string, 
    searchFields: (keyof T)[]
  ): Prisma.Enumerable<T>[] {
    const query = searchQuery?.trim() ?? ''
    const terms: string[] = query?.includes(' ')
      ? query.split(' ')
      : [query].filter(Boolean)
    
    if (terms.length === 0) return conditions

    const searchFilters = terms.map((term) => ({
      OR: searchFields.map((field) => ({
        [field]: { contains: term, mode: Prisma.QueryMode.insensitive },
      })),
    })) as unknown as T[]

    conditions.push(...searchFilters)
    return conditions
  }

  async countEntitiesWithPagination<T extends Record<string, any>>(
    countFunction: (args: { where?: T }) => Promise<number>,
    whereQuery: T,
    pagination: Pick<CorePagingInput, 'take' | 'skip'>
  ): Promise<CorePaging> {
    const where = whereQuery
    const total = await countFunction({})
    const count = await countFunction({ where })
    const { take = 10, skip = 0 } = pagination

    const page = Math.floor(skip / take)

    return {
      take,
      skip,
      page,
      count,
      total,
    }
  }

  async findMany<T extends Prisma.UserFindManyArgs>(
    args: Prisma.SelectSubset<T, Prisma.UserFindManyArgs>,
  ): Promise<{ 
    items: Prisma.UserGetPayload<T>[] 
    total: number 
    paging: CorePaging 
  }> {
    const [items, total] = await Promise.all([
      this.user.findMany(args),
      this.user.count({ where: args.where }),
    ])

    const take = args.take ?? 10
    const skip = args.skip ?? 0
    const page = Math.floor(skip / take)

    return {
      items,
      total,
      paging: {
        take,
        skip,
        page,
        count: items.length,
        total,
      },
    }
  }
}
