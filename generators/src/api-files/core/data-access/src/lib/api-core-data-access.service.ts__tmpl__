import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { Prisma, PrismaClient } from '../prisma/prisma-generated'
import { CorePagingInput } from './dto/core-paging.input'
import { withOptimize } from '@prisma/extension-optimize'

@Injectable()
export class ApiCoreDataAccessService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  constructor() {
    const config: Prisma.PrismaClientOptions = {
      datasources: {
        db: { url: `${process.env['DATABASE_URL']}?connection_limit=30` },
      },
      log:
        process.env['LOG_PRISMA_QUERIES'] === 'true' || process.env['COUNT_PRISMA_QUERIES'] === 'true'
          ? [{ emit: 'event', level: 'query' }]
          : [{ emit: 'event', level: 'warn' }],
    }
    super(config)
    this.queryCount = 0

    // Only add Prisma Optimize extension in development
    if (process.env['OPTIMIZE_API_KEY'] && process.env['USE_OPTIMIZE'] === 'true') {
      const apiKey = process.env['OPTIMIZE_API_KEY']
      if (!apiKey) {
        console.warn('Not Running Prisma Optimize - No API Key Set')
      }

      const extendedClient = new PrismaClient(config).$extends(withOptimize({ apiKey }))
      Object.assign(this, extendedClient)
    }
  }

  public queryCount: number

  public async onModuleDestroy(): Promise<void> {
    await this.$disconnect()
  }

  public async onModuleInit(): Promise<void> {
    await this.$connect()

    if (process.env['LOG_PRISMA_QUERIES'] == 'true') {
     this.$on('query' as never, async (e: Prisma.QueryEvent) => {
       console.log(`QUERY: ${e.query} \n\nPARAMS: ${e.params}\n\n\n`)
     })
    }

    if (process.env['COUNT_PRISMA_QUERIES'] == 'true') {
     this.$on('query' as never, async () => {
       this.queryCount++
     })
    }
  }

  filter<T extends Record<string, unknown>>(input: CorePagingInput = {}): {
    skip: number
    take: number
    where?: T
    orderBy: { [key: string]: 'asc' | 'desc' }
  } {
    const {
      search = '',
      searchFields = [],
      take = 20,
      skip = 0,
      orderBy = 'id',
      orderDirection = 'asc',
      filters = {},
    } = input

    const trimmedSearch = search.trim()
    const andConditions: unknown[] = []

    if (Object.keys(filters).length > 0) {
      andConditions.push(filters)
    }

    if (trimmedSearch && searchFields.length > 0) {
      const terms = trimmedSearch.includes(' ') ? trimmedSearch.split(' ') : [trimmedSearch].filter(Boolean)
      const searchFilters = terms.map((term) => ({
        OR: searchFields.map((field) => ({
          [field]: { contains: term, mode: Prisma.QueryMode.insensitive },
        })),
      }))
      andConditions.push(...searchFilters)
    }

    const where = andConditions.length > 0 ? { AND: andConditions } : undefined

    return {
      skip,
      take,
      where: where as unknown as T, // assert type safety for the generic
      orderBy: { [orderBy]: orderDirection },
    }
  }
}
