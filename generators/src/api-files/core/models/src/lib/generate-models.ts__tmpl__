import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';
import { getDMMF } from '@prisma/internals';

// Find project root and get schema path from package.json
function findProjectRoot(startDir: string) {
  try {
    // Try to use Nx's utility first if available
    try {
      const { findRootSync } = require('@nx/devkit');
      return findRootSync(startDir);
    } catch {
      // Fallback to process.cwd() which should be project root when running scripts
      return process.cwd();
    }
  } catch (error) {
    console.error('Error finding project root:', error);
    return process.cwd();
  }
}

// Determine the correct prisma import path based on package.json configuration
function getPrismaImportPath() {
  try {
    const projectRoot = findProjectRoot(__dirname);
    const packageJsonPath = join(projectRoot, 'package.json');
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));

    // If prisma schema is now in libs/api/prisma, we should import from there
    const schemaPath = packageJson.prisma?.schema || '';

    if (schemaPath.includes('prisma/src/lib')) {
      return '@<%= npmScope %>/api/prisma';
    }

    // Fallback to the original path
    return '@<%= npmScope %>/api/core/data-access';
  } catch (error) {
    console.error('Error determining Prisma import path:', error);
    // Default to the new path as per the request
    return '@<%= npmScope %>/api/prisma';
  }
}

// Get schema path from package.json
function getPrismaSchemaPath() {
  try {
    const projectRoot = findProjectRoot(__dirname);
    const packageJsonPath = join(projectRoot, 'package.json');
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));

    if (!packageJson.prisma?.schema) {
      throw new Error('prisma.schema not found in package.json');
    }

    // Join the project root with the schema path and append schema.prisma
    return join(projectRoot, packageJson.prisma.schema, 'schema.prisma');
  } catch (error) {
    console.error('Error getting Prisma schema path:', error);
    // Fallback to the old path for backward compatibility
    return join(__dirname, '../../../data-access/src/prisma/schemas/schema.prisma');
  }
}

// Paths
const schemaPath = getPrismaSchemaPath();
const outputDir = join(__dirname, './models');
const prismaImportPath = getPrismaImportPath();

async function main() {
  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Verify schema exists
  if (!existsSync(schemaPath)) {
    console.error(`Error: Prisma schema not found at ${schemaPath}`);
    console.error('Please check your package.json prisma.schema configuration');
    process.exit(1);
  }

  // Generate Prisma client first
  console.log(`Generating Prisma client using schema at ${schemaPath}...`);
  execSync(`npx prisma generate --schema ${schemaPath}`, { stdio: 'inherit' });

  // Read and parse schema
  console.log('Reading Prisma schema...');
  const schemaContent = readFileSync(schemaPath, 'utf-8');
  const dmmf = await getDMMF({ datamodel: schemaContent });

  // Extract models and enums from parsed schema
  const models = dmmf.datamodel.models;
  const enums = dmmf.datamodel.enums;

  // Generate models
  console.log('Generating TypeScript models...');
  const modelsOutput = generateModels(models, enums);
  writeFileSync(join(outputDir, 'models.ts'), modelsOutput);

  // Generate enums
  console.log('Generating TypeScript enums...');
  const enumsOutput = generateEnums(enums);
  writeFileSync(join(outputDir, 'enums.ts'), enumsOutput);

  // Generate index file
  console.log('Generating index file...');
  const indexOutput = generateIndex();
  writeFileSync(join(outputDir, 'index.ts'), indexOutput);

  console.log('Models and enums generated successfully!');
}

function generateModels(models: readonly any[], enums: readonly any[]): string {
  let output = `import { Field, ObjectType, Int, Float } from '@nestjs/graphql';\n`;
  output += `import { GraphQLJSONObject } from 'graphql-type-json';\n`;
  output += `import { Prisma, ${enums.map(e => e.name).join(', ')} } from '${prismaImportPath}';\n`;

  for (const model of models) {
    output += `@ObjectType()\nexport class ${model.name} {\n`;

    for (const field of model.fields) {
      const isList = field.isList;
      const isEnum = field.kind === 'enum';
      const isRelation = field.kind === 'object';
      const originalType = field.type;

      // DEBUG LINE ADDED HERE
      console.log(`DEBUG: Processing field: ${model.name}.${field.name}, Kind: ${field.kind}, OriginalType: ${originalType}`);

      // Determine the TypeScript type
      let tsType = originalType; // Default to originalType

      if (field.kind === 'scalar') {
          if (originalType === 'Int' || originalType === 'Float' || originalType === 'Decimal') {
              tsType = 'number';
          } else if (originalType === 'String' || originalType === 'ID') {
              tsType = 'string';
          } else if (originalType === 'Boolean') {
              tsType = 'boolean';
          } else if (originalType === 'DateTime') {
              tsType = 'Date';
          } else if (originalType === 'Json') {
              tsType = 'Prisma.JsonValue';
          }
          // Other scalars (e.g., BigInt, Bytes) will remain originalType if not handled above
      } else if (field.kind === 'enum') {
          tsType = originalType; // Stays as EnumName (e.g., UserRole)
      } else if (field.kind === 'object') {
          tsType = originalType; // Stays as RelatedModelName (e.g., Post)
      }

      // Generate the GraphQL decorator
      let decorator = '@Field(';
      const nullableOption = '{ nullable: true }';
      let decoratorType = '';

      if (originalType === 'Json' && !isList) {
          decoratorType = `() => GraphQLJSONObject`;
      } else if (originalType === 'Int' && !isList) {
          decoratorType = `() => Int`;
      } else if ((originalType === 'Float' || originalType === 'Decimal') && !isList) {
          decoratorType = `() => Float`;
      } else if (isScalarType(originalType) && !isList && originalType !== 'Decimal' && originalType !== 'Float' && originalType !== 'Int' && originalType !== 'Json') {
          decoratorType = '';
      } else if (isList) {
          let listItemGraphQLType = originalType;
          if (originalType === 'Int') listItemGraphQLType = 'Int';
          else if (originalType === 'Float' || originalType === 'Decimal') listItemGraphQLType = 'Float';
          else if (originalType === 'Json') listItemGraphQLType = 'GraphQLJSONObject';
          else if (isEnum || isRelation) listItemGraphQLType = originalType;
          else if (originalType === 'DateTime') listItemGraphQLType = 'Date';
          else if (originalType === 'Boolean') listItemGraphQLType = 'Boolean';
          else if (originalType.toLowerCase() === 'string' || originalType === 'ID') {
              listItemGraphQLType = 'String';
          }
          decoratorType = `() => [${listItemGraphQLType}]`;
      } else if (isEnum || isRelation) {
          decoratorType = `() => ${originalType}`;
      }

      if (decoratorType) {
          decorator += `${decoratorType}, ${nullableOption}`;
      } else {
          decorator += nullableOption;
      }
      decorator += ')';

      // Generate the field definition
      output += `  ${decorator}\n`;
      output += `  ${field.name}?: ${isRelation ? `Partial<${tsType}>` : tsType}${isList ? '[]' : ''};\n\n`;
    }

    output += `}\n\n`;
  }

  return output;
}

function generateEnums(enums: readonly any[]): string {
  let output = '// Generated from Prisma schema\n\n';
  output += "import { registerEnumType } from '@nestjs/graphql';\n";

  const enumNames = enums.map(e => e.name).join(', ');
  output += `import { ${enumNames} } from '${prismaImportPath}';\n\n`;

  enums.forEach((enumType) => {
    output += `registerEnumType(${enumType.name}, { name: '${enumType.name}' });\n\n`;
  });

  return output;
}

function generateIndex(): string {
  return `// Generated from Prisma schema
export * from './models';
export * from './enums';
`;
}

function isScalarType(type: string): boolean {
  return ['String', 'Int', 'Float', 'Boolean', 'DateTime', 'Json', 'ID', 'Decimal'].includes(type);
}

main().catch(console.error);
