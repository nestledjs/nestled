import { Field, ObjectType, Int, Float } from '@nestjs/graphql';
import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';
import { getDMMF } from '@prisma/internals';
import { GraphQLJSONObject } from 'graphql-type-json';
import { Prisma } from '@<%= npmScope %>/api/core/data-access'

interface PrismaField {
  readonly name: string;
  readonly type: string;
  readonly isRequired: boolean;
  readonly isList: boolean;
  readonly isUnique: boolean;
  readonly isId: boolean;
  readonly isReadOnly: boolean;
  readonly hasDefaultValue: boolean;
  readonly default?: any;
  readonly relationName?: string;
  readonly relationFromFields?: readonly string[];
  readonly relationToFields?: readonly string[];
  readonly relationOnDelete?: string;
  readonly documentation?: string;
}

interface PrismaModel {
  readonly name: string;
  readonly dbName: string | null;
  readonly fields: readonly PrismaField[];
  readonly isGenerated?: boolean;
  readonly documentation?: string;
}

interface PrismaEnum {
  readonly name: string;
  readonly values: readonly { readonly name: string; readonly dbName: string | null }[];
  readonly dbName?: string | null;
  readonly documentation?: string;
}

// Paths
const schemaPath = join(__dirname, '../../../data-access/src/lib/schema.prisma');
const outputDir = join(__dirname, './models');

async function main() {
  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Generate Prisma client first
  console.log('Generating Prisma client...');
  execSync(`npx prisma generate --schema ${schemaPath}`, { stdio: 'inherit' });

  // Read and parse schema
  console.log('Reading Prisma schema...');
  const schemaContent = readFileSync(schemaPath, 'utf-8');
  const dmmf = await getDMMF({ datamodel: schemaContent });

  // Extract models and enums from parsed schema
  const models = dmmf.datamodel.models;
  const enums = dmmf.datamodel.enums;

  // Generate models
  console.log('Generating TypeScript models...');
  const modelsOutput = generateModels(models, enums);
  writeFileSync(join(outputDir, 'models.ts'), modelsOutput);

  // Generate enums
  console.log('Generating TypeScript enums...');
  const enumsOutput = generateEnums(enums);
  writeFileSync(join(outputDir, 'enums.ts'), enumsOutput);

  // Generate index file
  console.log('Generating index file...');
  const indexOutput = generateIndex();
  writeFileSync(join(outputDir, 'index.ts'), indexOutput);

  console.log('Models and enums generated successfully!');
}

function generateModels(models: readonly any[], enums: readonly any[]): string {
  let output = `import { Field, ObjectType, Int, Float } from '@nestjs/graphql';\n`;
  output += `import { GraphQLJSONObject } from 'graphql-type-json';\n`;
  output += `import { Prisma, ${enums.map(e => e.name).join(', ')} } from '@<%= npmScope %>/api/core/data-access';\n`;

  for (const model of models) {
    output += `@ObjectType()\nexport class ${model.name} {\n`;

    for (const field of model.fields) {
      const isList = field.isList;
      const isEnum = field.kind === 'enum';
      const isRelation = field.kind === 'object';
      const originalType = field.type;
      const originalTypeIsScalar = isScalarType(originalType);

      // Determine the TypeScript type
      let fieldType = originalType;

      if (fieldType === 'DateTime') {
        fieldType = 'Date';
      } else if (fieldType === 'Int' || fieldType === 'Float') {
        fieldType = 'number';
      } else if (fieldType === 'Json') {
        fieldType = 'Prisma.JsonValue';
      } else if (originalTypeIsScalar) {
        fieldType = fieldType.toLowerCase();
      }

      // Generate the decorator
      let decorator = '@Field(';
      const nullableOption = '{ nullable: true }';
      let decoratorType = '';

      if (originalType === 'Json' && !isList) {
          decoratorType = `() => GraphQLJSONObject`;
      } else if (originalType === 'Int' && !isList) {
          decoratorType = `() => Int`;
      } else if (originalType === 'Float' && !isList) {
          decoratorType = `() => Float`;
      } else if (originalTypeIsScalar && !isList) {
          decoratorType = '';
      } else if (isList) {
          // Determine list item type for decorator using the *original* Prisma type
          let listItemGraphQLType = originalType; // Start with original type

          // Map specific Prisma types to GraphQL types for lists
          if (originalType === 'Int') listItemGraphQLType = 'Int';
          else if (originalType === 'Float') listItemGraphQLType = 'Float';
          else if (originalType === 'Json') listItemGraphQLType = 'GraphQLJSONObject';
          else if (isEnum || isRelation) listItemGraphQLType = originalType; // Keep original casing for relations/enums
          else if (originalType === 'DateTime') listItemGraphQLType = 'Date';
          else if (originalType === 'Boolean') listItemGraphQLType = 'Boolean';
          // Handle String/string/ID specifically for GraphQL [String]
          else if (originalType.toLowerCase() === 'string' || originalType === 'ID') {
              listItemGraphQLType = 'String'; // Ensure capitalized 'String' for GraphQL
          }
          // If it's not scalar, enum, or relation, it might be a complex type not handled yet.
          // Default uses originalType which might be correct.

          decoratorType = `() => [${listItemGraphQLType}]`;

      } else if (isEnum || isRelation) {
          decoratorType = `() => ${originalType}`;
      }

      if (decoratorType) {
          decorator += `${decoratorType}, ${nullableOption}`;
      } else {
          decorator += nullableOption;
      }

      decorator += ')';

      // Generate the field definition
      output += `  ${decorator}\n`;
      // Use the full type for the field definition
      output += `  ${field.name}?: ${isRelation ? `Partial<${fieldType}>` : fieldType}${isList ? '[]' : ''};\n\n`;
    }

    output += `}\n\n`;
  }

  return output;
}

function generateEnums(enums: readonly any[]): string {
  let output = '// Generated from Prisma schema\n\n';
  output += "import { registerEnumType } from '@nestjs/graphql';\n";

  // Create a single import statement with all enum types
  const enumNames = enums.map(e => e.name).join(', ');
  output += `import { ${enumNames} } from '@<%= npmScope %>/api/core/data-access';\n\n`;

  // Register each enum type
  enums.forEach((enumType) => {
    output += `registerEnumType(${enumType.name}, { name: '${enumType.name}' });\n\n`;
  });

  return output;
}

function generateIndex(): string {
  return `// Generated from Prisma schema
export * from './models';
export * from './enums';
`;
}

function isScalarType(type: string): boolean {
  return ['String', 'Int', 'Float', 'Boolean', 'DateTime', 'Json', 'ID'].includes(type);
}

main().catch(console.error);
