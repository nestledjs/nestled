import { Injectable } from '@nestjs/common'
import { ApiCoreDataAccessService, CorePaging, CorePagingInput } from '@<%= npmScope %>/api/core/data-access'
import { getGravatarUrl, hashPassword, uniqueSuffix } from '@<%= npmScope %>/api/auth/data-access'
import { AdminCreateUserInput } from './dto/admin-create-user.input'
import { AdminUpdateUserInput } from './dto/admin-update-user.input'


@Injectable()
export class ApiUserDataAccessService {
  constructor(private readonly data: ApiCoreDataAccessService) {}

  async adminUsers(userId: string, paging?: CorePagingInput) {
    await this.data.ensureAdminUser(userId);
    return this.data.user.findMany({
      take: paging?.take ?? 20,
      skip: paging?.skip ?? 0,
      include: { emails: true },
    });
  }

  async adminCountUsers(
    adminId: string,
    paging?: CorePagingInput
  ): Promise<CorePaging> {
    await this.data.ensureAdminUser(adminId);
    const total = await this.data.user.count();
    return {
      take: paging?.take ?? 20,
      skip: paging?.skip ?? 0,
      total,
    };
  }

  async adminUser(adminId: string, userId: string) {
    await this.data.ensureAdminUser(adminId);
    return this.data.user.findUnique({
      where: { id: userId },
      include: { emails: true },
    });
  }

  async adminCreateUser(adminId: string, input: AdminCreateUserInput) {
    await this.data.ensureAdminUser(adminId);
    const email = input?.email?.trim();
    if (!email) {
      throw new Error('Email is required to create a user.');
    }
    const displayName =
      input.displayName ||
      `${input.firstName} ${input.lastName}`.trim() ||
      email;

    return this.data.user.create({
      data: {
        emails: { create: { email, primary: true } },
        role: input.role ?? UserRole.USER,
        firstName: input.firstName,
        lastName: input.lastName,
        displayName,
      },
      include: { emails: true },
    });
  }

  async adminUpdateUser(
    adminId: string,
    userId: string,
    input: AdminUpdateUserInput
  ) {
    await this.data.ensureAdminUser(adminId);
    return this.data.user.update({
      where: { id: userId },
      data: { ...input },
      include: { emails: true },
    });
  }

  async adminSetUserPassword(
    adminId: string,
    userId: string,
    password: string
  ) {
    await this.data.ensureAdminUser(adminId);
    return this.data.user.update({
      where: { id: userId },
      data: { password: hashPassword(password) },
    });
  }

  async adminDeleteUser(adminId: string, userId: string) {
    await this.data.ensureAdminUser(adminId);
    return this.data.user.delete({ where: { id: userId } });
  }

  private formatdisplayName(email: string, displayName?: string): string {
    return displayName?.trim() || uniqueSuffix(email.trim().split('@')[0]);
  }

  private async ensuredisplayNameAvailable(
    displayName: string
  ): Promise<boolean> {
    const user = await this.data.findUserByDisplayName(displayName);
    if (user) {
      throw new Error(`This displayName is not available`);
    }
    return true;
  }

  private async ensureDisplayNameAvailable(
    displayName: string
  ): Promise<boolean> {
    const user = await this.data.findUserByDisplayName(displayName);
    if (user) {
      throw new Error(`This display name is not available`);
    }
    return true;
  }
}
