// /Users/justinhandley/IdeaProjects/nestled/forms/src/index.ts
export * from './lib/form'
export * from './lib/form-fields'
export * from './lib/form-types'


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/form-context.ts
import { createContext, useContext } from 'react'
import { UseFormReturn } from 'react-hook-form'

// The context will hold the entire return value of useForm()
export const FormContext = createContext<UseFormReturn | null>(null)

// A helper hook to easily access the context and provide a helpful error message.
export function useFormContext() {
  const context = useContext(FormContext)
  if (!context) {
    throw new Error('FormField components must be used within a <Form> component.')
  }
  return context
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/form-fields.ts
import {
  BaseFieldOptions,
  CheckboxOptions,
  ContentOptions,
  CurrencyFieldOptions,
  DatePickerOptions,
  EmailFieldOptions,
  EnumSelectOptions,
  FormField,
  FormFieldType,
  InputFieldOptions,
  NumberFieldOptions,
  PasswordFieldOptions,
  PhoneFieldOptions,
  SearchSelectOptions,
  SelectOptions,
  SwitchOptions,
  TextAreaOptions,
  UrlFieldOptions,
} from './form-types'

export class FormFieldClass {
  static field(type: FormFieldType, key: string, options: BaseFieldOptions = {}): FormField {
    return { type, key, options } as FormField
  }

  static input(key: string, options: InputFieldOptions = {}): FormField {
    return this.field(FormFieldType.Input, key, options)
  }

  static textArea(key: string, options: TextAreaOptions = {}): FormField {
    return this.field(FormFieldType.TextArea, key, options)
  }

  static email(key: string, options: EmailFieldOptions = {}): FormField {
    return this.field(FormFieldType.Email, key, options)
  }

  static password(key: string, options: PasswordFieldOptions = {}): FormField {
    return this.field(FormFieldType.Password, key, options)
  }

  static url(key: string, options: UrlFieldOptions = {}): FormField {
    return this.field(FormFieldType.Url, key, options)
  }

  static phone(key: string, options: PhoneFieldOptions = {}): FormField {
    return this.field(FormFieldType.Phone, key, options)
  }

  static number(key: string, options: NumberFieldOptions = {}): FormField {
    return this.field(FormFieldType.Number, key, options)
  }

  static currency(key: string, options: CurrencyFieldOptions = {}): FormField {
    return this.field(FormFieldType.Currency, key, options)
  }

  static checkbox(key: string, options: CheckboxOptions = {}): FormField {
    return this.field(FormFieldType.Checkbox, key, options)
  }

  static switch(key: string, options: SwitchOptions = {}): FormField {
    return this.field(FormFieldType.Switch, key, options)
  }

  static datePicker(key: string, options: DatePickerOptions = {}): FormField {
    return this.field(FormFieldType.DatePicker, key, options)
  }

  static select(key: string, options: SelectOptions): FormField {
    return this.field(FormFieldType.Select, key, options)
  }

  static enumSelect(key: string, options: EnumSelectOptions): FormField {
    return this.field(FormFieldType.EnumSelect, key, options)
  }

  static searchSelect<TDataItem>(key: string, options: SearchSelectOptions<TDataItem>): FormField {
    return this.field(FormFieldType.SearchSelect, key, options)
  }

  static searchSelectMulti<TDataItem>(key: string, options: SearchSelectOptions<TDataItem>): FormField {
    return this.field(FormFieldType.SearchSelectMulti, key, options)
  }

  static content(key: string, options: ContentOptions): FormField {
    return this.field(FormFieldType.Content, key, options)
  }
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/form-types.ts
import { DocumentNode, TypedDocumentNode } from '@apollo/client'
import { JSX, ReactNode } from 'react'
import { UseFormReturn } from 'react-hook-form'

// The single enum for all field types, combining the best of both libraries
export enum FormFieldType {
  Input = 'Input',
  TextArea = 'TextArea',
  Email = 'Email',
  Password = 'Password',
  Url = 'Url',
  Phone = 'Phone',
  Number = 'Number',
  Currency = 'Currency',
  Checkbox = 'Checkbox',
  Switch = 'Switch',
  DatePicker = 'DatePicker',
  DateTimePicker = 'DateTimePicker',
  TimePicker = 'TimePicker',
  Select = 'Select',
  EnumSelect = 'EnumSelect',
  MultiSelect = 'MultiSelect',
  Radio = 'Radio',
  SearchSelect = 'SearchSelect',
  SearchSelectMulti = 'SearchSelectMulti',
  Content = 'Content',
  Custom = 'Custom',
}

// A Base interface for options common to ALL fields
export interface BaseFieldOptions {
  label?: string
  required?: boolean
  hidden?: boolean
  disabled?: boolean
  customWrapper?: (children: ReactNode) => JSX.Element
  layout?: 'horizontal' | 'vertical'
  defaultValue?: any
  /**
   * If true, this specific field will be in read-only mode, overriding the form-level prop.
   */
  readOnly?: boolean;
  /**
   * Determines how the field should appear when in read-only mode.
   * 'value': Renders the data as plain text. (Default)
   * 'disabled': Renders the UI component in a disabled state.
   */
  readOnlyStyle?: 'value' | 'disabled';
}

// Specific options interfaces that extend the base
export interface InputFieldOptions extends BaseFieldOptions {
  placeholder?: string
}
export type UrlFieldOptions = InputFieldOptions
export type EmailFieldOptions = InputFieldOptions
export type PasswordFieldOptions = InputFieldOptions
export type PhoneFieldOptions = InputFieldOptions
export type NumberFieldOptions = InputFieldOptions
export type CurrencyFieldOptions = InputFieldOptions

export interface TextAreaOptions extends BaseFieldOptions {
  placeholder?: string
  rows?: number
}

export interface CheckboxOptions extends BaseFieldOptions {
  defaultValue?: boolean
  labelTextSize?: string
  fullWidthLabel?: boolean
  wrapperClassNames?: string
}

export interface SwitchOptions extends BaseFieldOptions {
  defaultValue?: boolean
}

export interface DatePickerOptions extends BaseFieldOptions {
  defaultValue?: string // YYYY-MM-DD
  useController?: boolean
}

export interface SelectOption {
  label: string
  value: string | number
}

export interface SelectOptions extends BaseFieldOptions {
  options: SelectOption[]
}

export interface EnumSelectOptions extends BaseFieldOptions {
  enum: { [s: string]: unknown } | ArrayLike<unknown>
}

export interface SearchSelectOption {
  label: string
  value: string
}

export interface SearchSelectOptions<TDataItem = any> extends BaseFieldOptions {
  document: DocumentNode | TypedDocumentNode
  dataType: string
  filter?: (items: TDataItem[]) => TDataItem[]
  selectOptionsFunction?: (items: TDataItem[]) => SearchSelectOption[]
}

export interface ContentOptions extends BaseFieldOptions {
  content: ReactNode
}

export interface CustomFieldRenderProps<T = unknown> {
  value: T
  onChange: (value: T) => void
  field: CustomFieldType<T>
}

export interface CustomFieldOptions<T = unknown> extends BaseFieldOptions {
  customField: (props: CustomFieldRenderProps<T>) => ReactNode
}

interface CustomFieldType<T = unknown> {
  key: string
  type: FormFieldType.Custom
  options: CustomFieldOptions<T>
}

// Specific interfaces for each complete field definition (discriminated union members)
interface InputField {
  key: string
  type: FormFieldType.Input
  options: InputFieldOptions
}
interface TextAreaField {
  key: string
  type: FormFieldType.TextArea
  options: TextAreaOptions
}
interface EmailField {
  key: string
  type: FormFieldType.Email
  options: EmailFieldOptions
}
interface PasswordField {
  key: string
  type: FormFieldType.Password
  options: PasswordFieldOptions
}
interface UrlField {
  key: string
  type: FormFieldType.Url
  options: UrlFieldOptions
}
interface PhoneField {
  key: string
  type: FormFieldType.Phone
  options: PhoneFieldOptions
}
interface NumberField {
  key: string
  type: FormFieldType.Number
  options: NumberFieldOptions
}
interface CurrencyField {
  key: string
  type: FormFieldType.Currency
  options: CurrencyFieldOptions
}
interface CheckboxField {
  key: string
  type: FormFieldType.Checkbox
  options: CheckboxOptions
}
interface SwitchField {
  key: string
  type: FormFieldType.Switch
  options: SwitchOptions
}
interface DatePickerField {
  key: string
  type: FormFieldType.DatePicker
  options: DatePickerOptions
}
interface SelectField {
  key: string
  type: FormFieldType.Select
  options: SelectOptions
}
interface EnumSelectField {
  key: string
  type: FormFieldType.EnumSelect
  options: EnumSelectOptions
}
interface SearchSelectField<TDataItem> {
  key: string
  type: FormFieldType.SearchSelect
  options: SearchSelectOptions<TDataItem>
}

interface SearchSelectMultiField<TDataItem> {
  key: string
  type: FormFieldType.SearchSelectMulti
  options: SearchSelectOptions<TDataItem>
}

interface ContentField {
  key: string
  type: FormFieldType.Content
  options: ContentOptions
}

// Add interfaces for new field types
interface MultiSelectField {
  key: string
  type: FormFieldType.MultiSelect
  options: SelectOptions
}
interface DateTimePickerField {
  key: string
  type: FormFieldType.DateTimePicker
  options: DatePickerOptions
}
interface TimePickerField {
  key: string
  type: FormFieldType.TimePicker
  options: BaseFieldOptions
}
interface RadioField {
  key: string
  type: FormFieldType.Radio
  options: RadioFormFieldOptions
}

export interface RadioOption {
  key: string;
  value: string | number | boolean;
  label: string;
  checkedSubOption?: {
    key: string;
    label: string;
  };
  hidden?: boolean;
}

export interface RadioFormFieldOptions extends BaseFieldOptions {
  radioOptions: RadioOption[];
  defaultValue?: string | number | boolean;
  defaultSubValue?: string;
  fullWidthLabel?: boolean;
  radioDirection?: 'row' | 'column';
  customWrapper?: (children: React.ReactNode) => JSX.Element;
  fancyStyle?: boolean;
  hidden?: boolean;
  disabled?: boolean;
}

// The final FormField is a union of all possible field shapes
export type FormField =
  | InputField
  | TextAreaField
  | EmailField
  | PasswordField
  | UrlField
  | PhoneField
  | NumberField
  | CurrencyField
  | CheckboxField
  | SwitchField
  | DatePickerField
  | DateTimePickerField
  | TimePickerField
  | SelectField
  | EnumSelectField
  | MultiSelectField
  | RadioField
  | SearchSelectField<any>
  | SearchSelectMultiField<any>
  | ContentField
  | CustomFieldType<any>

// A generic prop type for all individual field components
export interface FormFieldProps<T extends FormField> {
  field: T
  form: UseFormReturn
  hasError: boolean
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/form.tsx
import React, { useEffect } from 'react'
import { useForm, UseFormProps } from 'react-hook-form'
import { FormField } from './form-types'
import clsx from 'clsx'
import { FormContext } from './form-context'
import { RenderFormField } from './render-form-field' // Import the new renderer

export interface FormProps extends UseFormProps {
  fields?: (FormField | null)[] // For declarative rendering
  children?: React.ReactNode // For imperative rendering
  submit: (values: Record<string, unknown>) => Promise<unknown> | unknown
  buttonText?: string
  loading?: boolean
  className?: string
  /**
   * If true, the entire form is in read-only mode.
   */
  readOnly?: boolean;
  /**
   * Determines how the fields should appear when in read-only mode.
   * 'value': Renders the data as plain text. (Default)
   * 'disabled': Renders the UI component in a disabled state.
   */
  readOnlyStyle?: 'value' | 'disabled';
}

export function Form({
  fields,
  children,
  submit,
  buttonText = 'Submit',
  defaultValues,
  loading = false,
  className,
  readOnly = false,
  readOnlyStyle = 'value',
}: FormProps) {
  const form = useForm({ defaultValues })

  useEffect(() => {
    form.reset(defaultValues)
  }, [defaultValues, form])

  return (
    // Provide the form context to all children
    <FormContext.Provider value={form}>
      <form className={clsx('space-y-6', className)} onSubmit={form.handleSubmit(submit)}>
        {/* Render fields from the declarative array */}
        {fields?.map((field) =>
          field ? <RenderFormField key={field.key} field={field} formReadOnly={readOnly} formReadOnlyStyle={readOnlyStyle} /> : null
        )}

        {/* Render any manually placed fields */}
        {children}

        {/* Hide submit button in read-only mode */}
        {!readOnly && (
          <div className="mt-6">
            <button type="submit" disabled={loading} className={clsx(/* ... */)}>
              {loading ? 'Processing...' : buttonText}
            </button>
          </div>
        )}
      </form>
    </FormContext.Provider>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/render-form-field.tsx
import React from 'react'
import clsx from 'clsx'
import { FormField, FormFieldType } from './form-types'
import { useFormContext } from './form-context'

import { TextField } from './fields/text-field'
import { TextAreaField } from './fields/textarea-field'
import { EmailField } from './fields/email-field'
import { PasswordField } from './fields/password-field'
import { UrlField } from './fields/url-field'
import { PhoneField } from './fields/phone-field'
import { NumberField } from './fields/number-field'
import { MoneyField } from './fields/money-field'
import { CheckboxField } from './fields/checkbox-field'
import { SwitchField } from './fields/switch-field'
import { DatePickerField } from './fields/datepicker-field'
import { DateTimePickerField } from './fields/datetimepicker-field'
import { TimePickerField } from './fields/timepicker-field'
import { SelectField } from './fields/select-field'
import { MultiSelectField } from './fields/multiselect-field'
import { RadioField } from './fields/radio-field'
import { SearchSelectField } from './fields/search-select-field'
import { SearchSelectMultiField } from './fields/search-select-multi-field'
import { CustomField } from './fields/custom-field'

// This function remains internal to the renderer
function renderComponent(form: ReturnType<typeof useFormContext>, field: FormField, formReadOnly: boolean, formReadOnlyStyle: 'value' | 'disabled') {
  const hasError = !!form.formState.errors[field.key]

  switch (field.type) {
    case FormFieldType.Input:
      return (
        <TextField form={form} field={field as Extract<FormField, { type: FormFieldType.Input }>} hasError={hasError} formReadOnly={formReadOnly} formReadOnlyStyle={formReadOnlyStyle} />
      )
    case FormFieldType.TextArea:
      return (
        <TextAreaField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.TextArea }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Email:
      return (
        <EmailField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Email }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Password:
      return (
        <PasswordField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Password }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Url:
      return (
        <UrlField form={form} field={field as Extract<FormField, { type: FormFieldType.Url }>} hasError={hasError} formReadOnly={formReadOnly} formReadOnlyStyle={formReadOnlyStyle} />
      )
    case FormFieldType.Phone:
      return (
        <PhoneField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Phone }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Number:
      return (
        <NumberField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Number }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Currency:
      return (
        <MoneyField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Currency }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Select:
    case FormFieldType.EnumSelect:
      return (
        <SelectField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Select } | { type: FormFieldType.EnumSelect }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.MultiSelect:
      return (
        <MultiSelectField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.MultiSelect }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Checkbox:
      return (
        <CheckboxField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Checkbox }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Switch:
      return (
        <SwitchField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Switch }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.DatePicker:
      return (
        <DatePickerField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.DatePicker }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.DateTimePicker:
      return (
        <DateTimePickerField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.DateTimePicker }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.TimePicker:
      return (
        <TimePickerField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.TimePicker }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Radio:
      return (
        <RadioField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Radio }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.SearchSelect:
      return (
        <SearchSelectField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.SearchSelect }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.SearchSelectMulti:
      return (
        <SearchSelectMultiField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.SearchSelectMulti }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    case FormFieldType.Content:
      return field.options.content
    case FormFieldType.Custom:
      return (
        <CustomField
          form={form}
          field={field as Extract<FormField, { type: FormFieldType.Custom }>}
          hasError={hasError}
          formReadOnly={formReadOnly}
          formReadOnlyStyle={formReadOnlyStyle}
        />
      )
    default:
      return null
  }
}

// This is the exported component you will use
export function RenderFormField({ field, formReadOnly = false, formReadOnlyStyle = 'value' }: { field: FormField, formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const form = useFormContext() // Get the form context here

  const error = form.formState.errors[field.key]
  const errorMessage = (error?.message as string) ?? (error ? 'This field is required' : null)

  const label = field.options.label && (
    <label htmlFor={field.key} className={clsx()}>
      {field.options.label}
    </label>
  )

  const component = renderComponent(form, field, formReadOnly, formReadOnlyStyle)

  return (
    <div key={field.key} className={clsx()}>
      {label}
      <div className={clsx()}>
        {component}
        {error && <span className="text-red-700 text-sm">{errorMessage}</span>}
      </div>
    </div>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/checkbox-field.tsx
import { XMarkIcon } from '@heroicons/react/24/outline'
import { CheckIcon } from '@heroicons/react/24/solid'
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'

export function CheckboxField({
  form,
  field,
  hasError,
  formReadOnly = false,
  formReadOnlyStyle = 'value',
}: FormFieldProps<Extract<FormField, { type: FormFieldType.Checkbox }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const options = field.options

  const isReadOnly = options.readOnly ?? formReadOnly;
  const readOnlyStyle = options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key);

  const label = (
    <label
      htmlFor={field.key}
      className={clsx(options.labelTextSize || 'ml-2 mt-0.5 block text-xs sm:text-sm text-gray-900')}
    >
      {options.label}
    </label>
  )

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="checkbox"
          className={clsx('h-4 w-4 text-green_web border-gray-300 rounded', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          checked={!!value}
          readOnly
        />
      );
    }
    // Render as icon/plain value
    return value ? (
      <CheckIcon className="w-5 h-5 text-green_web" />
    ) : (
      <XMarkIcon className="w-5 h-5 text-red-600" />
    );
  }

  const input = (
    <input
      id={field.key}
      type="checkbox"
      disabled={options.disabled}
      defaultChecked={options.defaultValue}
      {...form.register(field.key, {
        required: options.required,
      })}
      className={clsx(
        'h-4 w-4 text-green_web focus:text-green_400_web focus:outline-none focus:ring-2 focus:ring-green_web focus:ring-offset-2 border-gray-300 rounded',
        hasError && '!border-red-600 !focus:border-red-600',
      )}
    />
  )

  const fullWidthLabel = options.fullWidthLabel
  const wrapperClassNames = options.wrapperClassNames

  return options.customWrapper ? (
    options.customWrapper(fullWidthLabel ? [label, input] : [input, label])
  ) : (
    <div
      key={`${field.key}_wrapper`}
      className={clsx('flex items-center', fullWidthLabel ? 'justify-between' : 'justify-start', wrapperClassNames)}
    >
      {fullWidthLabel ? label : null}
      {input}
      {!fullWidthLabel ? label : null}
    </div>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/custom-field.tsx
import React from 'react'
import { FormField, FormFieldProps, FormFieldType, CustomFieldRenderProps } from '../form-types'

export function CustomField<T = unknown>({
  form,
  field,
  hasError,
  formReadOnly = false,
  formReadOnlyStyle = 'value',
}: FormFieldProps<Extract<FormField, { type: FormFieldType.Custom }>> & { hasError?: boolean, formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? field.options.defaultValue;

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      // Render as disabled input (fallback to string value)
      return (
        <input
          type="text"
          disabled={true}
          value={typeof value === 'string' ? value : JSON.stringify(value)}
          className="min-h-[2.5rem] flex items-center px-3 text-gray-700 w-full border border-gray-300 rounded"
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{typeof value === 'string' ? value : JSON.stringify(value) || '—'}</div>
    );
  }

  // Create render props for the custom field
  const renderProps: CustomFieldRenderProps<T> = {
    value: value as T,
    onChange: (value: T) => {
      form.setValue(field.key, value)
    },
    field: field,
  }

  try {
    // Render the custom field component with the render props
    return field.options.customField(renderProps)
  } catch (error) {
    console.error('Error rendering custom field:', error)
    return <div className="text-red-600">Error rendering custom field: {field.key}</div>
  }
}

CustomField.displayName = 'CustomField'


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/datepicker-field.tsx
import { formatDateFromDateTime, getDateFromDateTime } from '../utils/date-time'
import { Controller } from 'react-hook-form'
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'

export function DatePickerField({
  form,
  field,
  hasError,
  formReadOnly = false,
  formReadOnlyStyle = 'value',
}: FormFieldProps<Extract<FormField, { type: FormFieldType.DatePicker }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="date"
          className={clsx('text-green_web py-1.5 border-gray-300 focus:border-gray-300 rounded w-full focus:outline-none',
            hasError ? 'border-red-600 focus:ring-red-600' : 'focus:ring-green_web active:ring-green_web',
          )}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value (formatted)
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{formatDateFromDateTime(value || '') || '—'}</div>
    );
  }

  if (field.options.useController) {
    return (
      <Controller
        name={field.key}
        control={form.control}
        defaultValue={getDateFromDateTime(field.options.defaultValue || '')}
        render={({ field: { value, onChange, ...controllerField } }) => (
          <input
            {...controllerField}
            value={value || ''}
            type="date"
            max="9999-12-31"
            contentEditable={false}
            disabled={field.options.disabled}
            className={clsx(
              'text-green_web py-1.5 border-gray-300 focus:border-gray-300 rounded w-full focus:outline-none',
              hasError ? 'border-red-600 focus:ring-red-600' : 'focus:ring-green_web active:ring-green_web',
            )}
            onChange={(e) => {
              onChange(e.target.value)
            }}
          />
        )}
      />
    )
  }
  return (
    <input
      id={field.key}
      type="date"
      max="9999-12-31"
      contentEditable={false}
      disabled={field.options.disabled}
      defaultValue={getDateFromDateTime(field.options.defaultValue || '') || ''}
      {...form.register(field.key, {
        required: field.options.required,
        setValueAs: (v) => (v ? v.split('T')[0] : ''),
      })}
      onChange={(val) => {
        // Optionally handle onChange
      }}
      className={clsx(
        'text-green_web py-1.5 border-gray-300 focus:border-gray-300 rounded w-full focus:outline-none',
        hasError ? 'border-red-600 focus:ring-red-600' : 'focus:ring-green_web active:ring-green_web',
      )}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/datetimepicker-field.tsx
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'

export function DateTimePickerField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.DateTimePicker }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="datetime-local"
          className={clsx('text-green_web focus:ring-green_web border-gray-300 rounded w-full', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value || '—'}</div>
    );
  }

  return (
    <input
      id={field.key}
      type="datetime-local"
      disabled={field.options.disabled}
      defaultValue={field.options.defaultValue}
      {...form.register(field.key, {
        required: field.options.required,
        valueAsDate: true,
      })}
      className={clsx('text-green_web focus:ring-green_web border-gray-300 rounded w-full', hasError && '!border-red-600 !focus:border-red-600')}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/email-field.tsx
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'
import { inputStyle } from '../styles/input-style'

export function EmailField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.Email }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="email"
          className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value || '—'}</div>
    );
  }

  return (
    <input
      id={field.key}
      type="email"
      autoComplete="true"
      disabled={field.options.disabled}
      placeholder={field.options.placeholder}
      defaultValue={field.options.defaultValue}
      {...form.register(field.key, { required: field.options.required })}
      className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/money-field.tsx
import clsx from 'clsx'
import React from 'react'
import { FormField, FormFieldType, FormFieldProps } from '../form-types'
import { inputStyle } from '../styles/input-style' // New location for shared styles
import './money-field-style.css'

// The component now accepts the new props structure and is strongly typed.
// We use `Extract` to get the specific member of the FormField union we care about.
export function MoneyField({
  form,
  field,
  hasError,
  formReadOnly = false,
  formReadOnlyStyle = 'value',
}: FormFieldProps<Extract<FormField, { type: FormFieldType.Currency }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <div id="money" className="flex flex-row items-center">
          <div id="moneySign">$</div>
          <input
            id={field.key}
            type="number"
            step="0.01"
            disabled={true}
            value={value}
            className={clsx(inputStyle, { '!border-red-600 !focus:border-red-600': hasError })}
          />
        </div>
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">${value || '—'}</div>
    );
  }

  return (
    <div id="money" className="flex flex-row items-center">
      <div id="moneySign">$</div>
      <input
        id={field.key}
        type="number"
        step="0.01"
        // Use the `form` object from react-hook-form
        {...form.register(field.key, {
          required: field.options.required,
          valueAsNumber: true,
        })}
        // Access options directly from the `field` prop
        disabled={field.options.disabled}
        defaultValue={field.options.defaultValue}
        placeholder={field.options.placeholder}
        className={clsx(inputStyle, {
          '!border-red-600 !focus:border-red-600': hasError,
        })}
      />
    </div>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/multiselect-field.tsx
import { Combobox, ComboboxInput, ComboboxButton, ComboboxOption, ComboboxOptions } from '@headlessui/react'
import { useState } from 'react'
import clsx from 'clsx'
import { FormFieldProps, FormField, FormFieldType } from '../form-types'
import { ClientOnly } from '../utils/client-only'
import { useDebounce } from '../utils/debounce'
import './select-field-style.css'
import { Controller } from 'react-hook-form'

export function MultiSelectField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.MultiSelect }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const [searchTerm, setSearchTerm] = useState('')
  const debouncedSearchTerm = useDebounce(searchTerm, 300)
  const options = field.options.options || []

  // Filter options by search term
  const filteredOptions = debouncedSearchTerm
    ? options.filter((option: { label: string; value: string | number }) =>
        option.label.toLowerCase().includes(debouncedSearchTerm.toLowerCase())
      )
    : options

  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? [];
  const selectedLabels = Array.isArray(value) ? value.map((v: any) => v.label || v).join(', ') : '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          type="text"
          className={clsx('w-full bg-white border border-gray-300 rounded-md shadow-sm py-2 pl-3 pr-10', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={selectedLabels}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{selectedLabels || '—'}</div>
    );
  }

  return (
    <ClientOnly fallback={<div className="min-h-[2.5rem] w-full rounded-md border border-gray-300 bg-gray-100" />}> 
      <Controller
        name={field.key}
        control={form.control}
        defaultValue={[]}
        render={({ field: { onChange, value = [] } }) => (
          <Combobox
            multiple
            value={value}
            onChange={onChange}
          >
            <div className="relative">
              <div className={clsx(
                'flex flex-wrap items-center gap-1 rounded-md border border-gray-300 bg-white p-1 pr-10 shadow-sm',
                hasError && '!border-red-600 !focus:border-red-600'
              )}>
                {value.map((item: { label: string; value: string | number }) => (
                  <span
                    key={item.value}
                    className="flex items-center gap-x-1 whitespace-nowrap rounded-sm bg-orange-100 px-2 py-0.5 text-sm text-orange-700"
                  >
                    {item.label}
                    <button
                      type="button"
                      className="text-orange-500 hover:text-orange-800"
                      onClick={() => onChange(value.filter((v: { label: string; value: string | number }) => v.value !== item.value))}
                    >
                      <svg className="h-3 w-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </span>
                ))}
                <ComboboxInput
                  className="min-w-[6rem] flex-grow bg-transparent p-1 focus:ring-0 border-none"
                  onChange={(event) => setSearchTerm(event.target.value)}
                  placeholder={value.length === 0 ? field.options.label : ''}
                />
              </div>
              <ComboboxButton className="absolute inset-y-0 right-0 flex items-center pr-2">
                <svg className="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                  <path
                    fillRule="evenodd"
                    d="M10 3a.75.75 0 01.53.22l3.5 3.5a.75.75 0 01-1.06 1.06L10 4.81 6.53 8.28a.75.75 0 01-1.06-1.06l3.5-3.5A.75.75 0 0110 3zm-3.72 9.28a.75.75 0 011.06 0L10 15.19l3.47-3.47a.75.75 0 111.06 1.06l-4 4a.75.75 0 01-1.06 0l-4-4a.75.75 0 010-1.06z"
                    clipRule="evenodd"
                  />
                </svg>
              </ComboboxButton>
            </div>
            <ComboboxOptions className="absolute z-10 mt-1 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-base ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none sm:text-sm">
              {filteredOptions.map((option: { label: string; value: string | number }) => (
                <ComboboxOption
                  key={option.value}
                  value={option}
                  className={({ active }) =>
                    clsx(
                      'cursor-pointer select-none relative py-2 pl-10 pr-4',
                      active ? 'bg-orange-100 text-orange-900' : 'text-gray-900'
                    )
                  }
                >
                  {({ selected }) => (
                    <>
                      <span
                        className={clsx(
                          'block truncate',
                          selected ? 'font-medium' : 'font-normal'
                        )}
                      >
                        {option.label}
                      </span>
                      {selected ? (
                        <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-orange-600">
                          <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" />
                          </svg>
                        </span>
                      ) : null}
                    </>
                  )}
                </ComboboxOption>
              ))}
            </ComboboxOptions>
          </Combobox>
        )}
      />
    </ClientOnly>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/number-field.tsx
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'
import { inputStyle } from '../styles/input-style'

export function NumberField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.Number }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="number"
          className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value || '—'}</div>
    );
  }

  return (
    <input
      id={field.key}
      type="number"
      disabled={field.options.disabled}
      placeholder={field.options.placeholder}
      defaultValue={field.options.defaultValue}
      {...form.register(field.key, { required: field.options.required, valueAsNumber: true })}
      className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/password-field.tsx
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'
import { inputStyle } from '../styles/input-style'

export function PasswordField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.Password }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="password"
          className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as masked value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{'*'.repeat(value.length) || '—'}</div>
    );
  }

  return (
    <input
      id={field.key}
      type="password"
      disabled={field.options.disabled}
      placeholder={field.options.placeholder}
      defaultValue={field.options.defaultValue}
      {...form.register(field.key, { required: field.options.required })}
      className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/phone-field.tsx
import 'react-phone-number-input/style.css'
import './phone-field.css'
import { useEffect, useState } from 'react'
import { isPossiblePhoneNumber } from 'react-phone-number-input'
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'

export function PhoneField({
  form,
  field,
  hasError,
  formReadOnly = false,
  formReadOnlyStyle = 'value',
}: FormFieldProps<Extract<FormField, { type: FormFieldType.Phone }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const [, setValue] = useState<string>(field.options.defaultValue?.toString() ?? '')

  useEffect(() => {
    setValue(field.options.defaultValue?.toString())
  }, [field.options.defaultValue])

  function validatePhone(val: string) {
    return val === undefined || val === '' || isPossiblePhoneNumber((val ?? '')?.toString(), 'US')
  }

  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="tel"
          className={clsx('w-full', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value || '—'}</div>
    );
  }

  return (
    <>
      <input
        id={field.key}
        type="tel"
        disabled={field.options.disabled}
        placeholder={field.options.placeholder}
        defaultValue={field.options.defaultValue}
        {...form.register(field.key, {
          validate: (v) => validatePhone(v),
        })}
        className={clsx('w-full', hasError && '!border-red-600 !focus:border-red-600')}
      />
      {hasError && <div className="text-2xs sm:text-sm mt-2 mx-1 text-red-700">* Phone number is invalid</div>}
    </>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/radio-field.tsx
import { XMarkIcon } from '@heroicons/react/24/outline'
import { CheckIcon } from '@heroicons/react/24/solid'
import { useEffect, useState } from 'react'
import { FormFieldProps, FormField, FormFieldType, RadioOption, RadioFormFieldOptions } from '../form-types'
import { inputStyle } from '../styles/input-style'
import './radio-field-style.css'
import { Controller } from 'react-hook-form'

export function RadioField(
  props: FormFieldProps<Extract<FormField, { type: FormFieldType.Radio }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }
) {
  const [subOptionKey, setSubOptionKey] = useState<string>()
  const [subOptionValue, setSubOptionValue] = useState<string>('')
  const options: RadioFormFieldOptions = props.field?.options as RadioFormFieldOptions

  useEffect(() => {
    if (options?.defaultValue !== undefined) {
      const defaultOption = options?.radioOptions?.find((o: RadioOption) => o.value === options?.defaultValue)
      if (props.form.setValue) {
        props.form.setValue(props.field.key, defaultOption?.value)
      }
      if (options?.defaultSubValue !== undefined && defaultOption?.checkedSubOption) {
        setSubOptionKey(defaultOption?.checkedSubOption?.key)
        setSubOptionValue(options?.defaultSubValue)
        if (props.form.setValue) {
          props.form.setValue(defaultOption?.checkedSubOption?.key, options?.defaultSubValue)
        }
      }
    }
  }, [options?.defaultValue, options?.defaultSubValue, props.form.setValue, props.field.key, options, options.radioOptions, props.form, props.field])

  const isReadOnly = options.readOnly ?? props.formReadOnly;
  const readOnlyStyle = options.readOnlyStyle ?? props.formReadOnlyStyle;
  const value = props.form.getValues(props.field.key);
  const selectedOption = options.radioOptions?.find((o) => o.value === value);

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      // Render disabled radio inputs
      return (
        <div className={`flex w-full ${options.radioDirection !== 'row' ? 'flex-col gap-y-1' : 'flex-row gap-x-4'}`}>
          {options?.radioOptions?.map((option: RadioOption) => (
            <div key={option.key + '_container'} className="flex flex-row items-center">
              <input
                type="radio"
                id={option.key}
                name={props.field.key}
                checked={option.value === value}
                disabled={true}
                className={inputStyle}
                readOnly
              />
              <label htmlFor={option.key} className="text-sm ml-2 grow">
                <span className="sr-only">{option.label.replace(/<[^>]+>/g, '')}</span>
                <div dangerouslySetInnerHTML={{ __html: option.label }} />
              </label>
            </div>
          ))}
        </div>
      );
    }
    // Render as icon/plain value
    if (selectedOption) {
      return (
        <div className="flex flex-row items-center">
          <CheckIcon className="w-5 h-5 text-green_web" />
          <span className="pl-2">{selectedOption.label}</span>
        </div>
      );
    }
    return <XMarkIcon className="w-5 h-5 text-red-600" />;
  }

  return (
    <Controller
      name={props.field.key}
      control={props.form.control}
      defaultValue={options?.defaultValue}
      render={({ field: { value, onChange } }) => (
        <div className={`flex w-full ${options.radioDirection !== 'row' ? 'flex-col gap-y-1' : 'flex-row gap-x-4'}`}>
          {options?.radioOptions?.map((option: RadioOption) => (
            <div
              key={option.key + '_container'}
              className={`${options?.fullWidthLabel ? 'w-100  justify-between' : ''}
                ${option.checkedSubOption ? 'grow' : ''}
                ${options.radioDirection !== 'row' ? 'flex-col justify-center' : 'flex-row items-center'}
                flex
              `}
            >
              <div
                className={`flex grow ${
                  options.radioDirection !== 'row' ? 'flex-col justify-center' : 'flex-row items-center'
                }`}
              >
                <div className={`flex flex-row items-center ${options.fancyStyle ? 'border rounded-md' : ''}`}>
                  {options?.fullWidthLabel ? (
                    <label htmlFor={option.key} className="text-sm ml-2 grow">
                      <span className="sr-only">{option.label.replace(/<[^>]+>/g, '')}</span>
                      <div dangerouslySetInnerHTML={{ __html: option.label }} />
                    </label>
                  ) : null}
                  <input
                    onChange={() => {
                      onChange(option.value)
                      if (option?.checkedSubOption?.key) {
                        setSubOptionKey(option.checkedSubOption.key)
                        setSubOptionValue('')
                        if (props.form.setValue) {
                          props.form.setValue(option.checkedSubOption.key, '')
                        }
                      } else if (subOptionKey) {
                        setSubOptionKey(undefined)
                        setSubOptionValue('')
                        if (props.form.setValue) {
                          props.form.setValue(subOptionKey, '')
                        }
                      }
                    }}
                    type="radio"
                    className={`${options?.fullWidthLabel ? 'check' : ''} ${
                      options?.hidden || option?.hidden ? 'opacity-0' : ''
                    } ${options.radioDirection !== 'row' ? 'ml-4' : ''}`}
                    id={option.key}
                    name={props.field.key}
                    value={String(option.value ?? '')}
                    checked={option?.value === value}
                    disabled={options?.disabled}
                  />
                  {!options?.fullWidthLabel ? (
                    <label
                      htmlFor={option.key}
                      className={`text-sm grow ${options.radioDirection !== 'row' ? 'p-4' : 'p-1 pl-2'}`}
                    >
                      <span className="sr-only">{option.label.replace(/<[^>]+>/g, '')}</span>
                      <div dangerouslySetInnerHTML={{ __html: option.label }} />
                    </label>
                  ) : null}
                </div>
                {option?.value === value && option?.checkedSubOption ? (
                  <input
                    {...(option?.checkedSubOption?.key ? props.form.register(option.checkedSubOption.key) : {})}
                    name={option?.checkedSubOption?.key ?? ''}
                    placeholder={options?.radioDirection === 'row' ? option?.checkedSubOption?.label ?? '' : undefined}
                    disabled={options?.disabled}
                    onChange={(e) => {
                      setSubOptionKey(option?.checkedSubOption?.key ?? '')
                      setSubOptionValue(e?.target?.value)
                      if (props.form.setValue) {
                        props.form.setValue(option?.checkedSubOption?.key ?? '', e?.target?.value)
                      }
                    }}
                    value={subOptionValue}
                    className={`grow ${inputStyle} ${props.hasError ? 'border-red-600 focus:border-red-600' : ''}`}
                  />
                ) : null}
              </div>
            </div>
          ))}
        </div>
      )}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/search-select-field.tsx
import { useQuery } from '@apollo/client'
import { Combobox, ComboboxButton, ComboboxInput, ComboboxOption, ComboboxOptions } from '@headlessui/react'
import { Controller } from 'react-hook-form'
import { useEffect, useState, useCallback } from 'react'
import clsx from 'clsx'
import { SearchSelectOption, FormField, FormFieldProps, FormFieldType } from '../form-types'
import { useDebounce } from '../utils/debounce'
import { ClientOnly } from '../utils/client-only'

function defaultOptionsMap<TDataItem extends { id: string; name?: string; firstName?: string; lastName?: string }>(
  items: TDataItem[],
): SearchSelectOption[] {
  return items.map((option) => ({
    value: `${option.id}`,
    label: option.name ?? `${option.firstName} ${option.lastName}`,
  }))
}

export function SearchSelectField<
  TDataItem extends { id: string; name?: string; firstName?: string; lastName?: string }
>({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.SearchSelect }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const { data, loading: apolloLoading, refetch } = useQuery(field.options.document)
  const [searchTerm, setSearchTerm] = useState('')
  const [options, setOptions] = useState<SearchSelectOption[]>([])
  const debouncedSearchTerm = useDebounce(searchTerm, 500)

  const processData = useCallback((dataList: TDataItem[]) => {
    let processedList = dataList
    if (field.options.filter) {
      processedList = field.options.filter(processedList)
    }
    return field.options.selectOptionsFunction
      ? field.options.selectOptionsFunction(processedList)
      : defaultOptionsMap(processedList)
  }, [field.options])

  useEffect(() => {
    if (!apolloLoading && data) {
      setOptions(processData(data[field.options.dataType] ?? []))
    }
  }, [apolloLoading, data, field.options.dataType, processData])

  useEffect(() => {
    if (debouncedSearchTerm) {
      refetch({ input: { search: debouncedSearchTerm } }).then((res) => {
        setOptions(processData(res.data?.[field.options.dataType] ?? []))
      })
    }
  }, [debouncedSearchTerm, refetch, field.options, processData])

  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key);
  const selectedOption = options.find((o) => o.value === value) || null;

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          type="text"
          className={clsx('w-full bg-white border border-gray-300 rounded-md shadow-sm py-2 pl-3 pr-10', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={selectedOption?.label || ''}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{selectedOption?.label || '—'}</div>
    );
  }

  return (
    <ClientOnly fallback={<div className="h-10 w-full rounded-md border border-gray-300 bg-gray-100" />}>
      <Controller
        control={form.control}
        name={field.key}
        defaultValue={field.options.defaultValue}
        rules={{ required: field.options.required }}
        render={({ field: { onChange, value, onBlur } }) => (
          <Combobox<SearchSelectOption | null> value={value} onChange={onChange} nullable>
            <div className="relative">
              <ComboboxInput
                className={clsx('w-full bg-white border border-gray-300 rounded-md shadow-sm py-2 pl-3 pr-10', hasError && '!border-red-600 !focus:border-red-600')}
                onChange={(event) => setSearchTerm(event.target.value)}
                onBlur={onBlur}
                displayValue={(option: SearchSelectOption | null) => option?.label ?? ''}
                placeholder={field.options.label}
              />
              <ComboboxButton className="absolute inset-y-0 right-0 flex items-center pr-2">
                <svg
                  className="h-5 w-5 text-gray-400"
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fillRule="evenodd"
                    d="M10 3a.75.75 0 01.53.22l3.5 3.5a.75.75 0 01-1.06 1.06L10 4.81 6.53 8.28a.75.75 0 01-1.06-1.06l3.5-3.5A.75.75 0 0110 3zm-3.72 9.28a.75.75 0 011.06 0L10 15.19l3.47-3.47a.75.75 0 111.06 1.06l-4 4a.75.75 0 01-1.06 0l-4-4a.75.75 0 010-1.06z"
                    clipRule="evenodd"
                  />
                </svg>
              </ComboboxButton>
            </div>
            <ComboboxOptions className="absolute z-10 mt-1 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-base ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none sm:text-sm">
              {apolloLoading && <div className="p-2 text-sm text-gray-500">Loading...</div>}
              {options.map((option) => (
                <ComboboxOption
                  key={option.value}
                  value={option}
                  className={({ active }) =>
                    `cursor-default select-none relative py-2 pl-10 pr-4 ${
                      active ? 'text-white bg-orange-600' : 'text-gray-900'
                    }`
                  }
                >
                  {({ selected }) => (
                    <>
                      <span className={`block truncate ${selected ? 'font-medium' : 'font-normal'}`}>
                        {option.label}
                      </span>
                      {selected && (
                        <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-orange-600">
                          <svg
                            className="h-5 w-5"
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 20 20"
                            fill="currentColor"
                          >
                            <path
                              fillRule="evenodd"
                              d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.052-.143z"
                              clipRule="evenodd"
                            />
                          </svg>
                        </span>
                      )}
                    </>
                  )}
                </ComboboxOption>
              ))}
            </ComboboxOptions>
          </Combobox>
        )}
      />
    </ClientOnly>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/search-select-multi-field.tsx
import { useQuery } from '@apollo/client'
import { Combobox } from '@headlessui/react'
import { Controller } from 'react-hook-form'
import { useEffect, useState, useCallback } from 'react'
import clsx from 'clsx'
import { SearchSelectOption, FormField, FormFieldProps, FormFieldType } from '../form-types'
import { useDebounce } from '../utils/debounce'
import { ClientOnly } from '../utils/client-only'

type RequiredItemShape = { id: string; name?: string; firstName?: string; lastName?: string }

function defaultOptionsMap<TDataItem extends { id: string; name?: string; firstName?: string; lastName?: string }>(
  items: TDataItem[],
): SearchSelectOption[] {
  return items.map((option) => ({
    value: `${option.id}`,
    label: option.name ?? `${option.firstName} ${option.lastName}`,
  }))
}

export function SearchSelectMultiField<TDataItem extends RequiredItemShape>({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.SearchSelectMulti }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const { data, loading: apolloLoading, refetch } = useQuery(field.options.document)
  const [searchTerm, setSearchTerm] = useState('')
  const [options, setOptions] = useState<SearchSelectOption[]>([])
  const debouncedSearchTerm = useDebounce(searchTerm, 500)

  const processData = useCallback((dataList: TDataItem[]) => {
    let processedList = dataList
    if (field.options.filter) processedList = field.options.filter(processedList)
    return field.options.selectOptionsFunction
      ? field.options.selectOptionsFunction(processedList)
      : defaultOptionsMap(processedList)
  }, [field.options])

  useEffect(() => {
    if (!apolloLoading && data) setOptions(processData(data[field.options.dataType] ?? []))
  }, [apolloLoading, data, field.options.dataType, processData])

  useEffect(() => {
    if (debouncedSearchTerm) {
      refetch({ input: { search: debouncedSearchTerm } }).then((res) => {
        setOptions(processData(res.data?.[field.options.dataType] ?? []))
      })
    }
  }, [debouncedSearchTerm, refetch, field.options, processData])

  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? [];
  const selectedLabels = Array.isArray(value) ? value.map((v: any) => v.label || v).join(', ') : '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          type="text"
          className={clsx('w-full bg-white border border-gray-300 rounded-md shadow-sm py-2 pl-3 pr-10', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={selectedLabels}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{selectedLabels || '—'}</div>
    );
  }

  return (
    <ClientOnly fallback={<div className="min-h-[2.5rem] w-full rounded-md border border-gray-300 bg-gray-100" />}>
      <Controller
        control={form.control}
        name={field.key}
        defaultValue={field.options.defaultValue ?? []}
        rules={{ required: field.options.required }}
        render={({ field: { onChange, value = [] } }) => (
          <Combobox
            multiple
            value={value}
            onChange={(items) => {
              onChange(items)
              setSearchTerm('') // Clear search input after selection
            }}
          >
            <div className="relative">
              <div className={clsx('flex flex-wrap items-center gap-1 rounded-md border border-gray-300 bg-white p-1 pr-10 shadow-sm', hasError && '!border-red-600 !focus:border-red-600')}>
                {value.map((item: SearchSelectOption) => (
                  <span
                    key={item.value}
                    className="flex items-center gap-x-1 whitespace-nowrap rounded-sm bg-orange-100 px-2 py-0.5 text-sm text-orange-700"
                  >
                    {item.label}
                    <button
                      type="button"
                      className="text-orange-500 hover:text-orange-800"
                      onClick={() => onChange(value.filter((v: SearchSelectOption) => v.value !== item.value))}
                    >
                      <svg className="h-3 w-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </span>
                ))}
                <Combobox.Input
                  className="min-w-[6rem] flex-grow bg-transparent p-1 focus:ring-0 border-none"
                  onChange={(event) => setSearchTerm(event.target.value)}
                  placeholder={value.length === 0 ? field.options.label : ''}
                />
              </div>
              <Combobox.Button className="absolute inset-y-0 right-0 flex items-center pr-2">
                <svg className="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                  <path
                    fillRule="evenodd"
                    d="M10 3a.75.75 0 01.53.22l3.5 3.5a.75.75 0 01-1.06 1.06L10 4.81 6.53 8.28a.75.75 0 01-1.06-1.06l3.5-3.5A.75.75 0 0110 3zm-3.72 9.28a.75.75 0 011.06 0L10 15.19l3.47-3.47a.75.75 0 111.06 1.06l-4 4a.75.75 0 01-1.06 0l-4-4a.75.75 0 010-1.06z"
                    clipRule="evenodd"
                  />
                </svg>
              </Combobox.Button>
            </div>
            <Combobox.Options className="absolute z-10 mt-1 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-base ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none sm:text-sm">
              {apolloLoading && <div className="p-2 text-sm text-gray-500">Loading...</div>}
              {options.map((option) => (
                <Combobox.Option
                  key={option.value}
                  value={option}
                  className={({ active }) =>
                    `cursor-default select-none relative py-2 pl-10 pr-4 ${
                      active ? 'text-white bg-orange-600' : 'text-gray-900'
                    }`
                  }
                >
                  {({ selected }) => (
                    <>
                      <span className={`block truncate ${selected ? 'font-medium' : 'font-normal'}`}>
                        {option.label}
                      </span>
                      {selected && (
                        <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-orange-600">
                          <svg
                            className="h-5 w-5"
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 20 20"
                            fill="currentColor"
                          >
                            <path
                              fillRule="evenodd"
                              d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.052-.143z"
                              clipRule="evenodd"
                            />
                          </svg>
                        </span>
                      )}
                    </>
                  )}
                </Combobox.Option>
              ))}
            </Combobox.Options>
          </Combobox>
        )}
      />
    </ClientOnly>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/select-field.tsx
import { Combobox, ComboboxInput, ComboboxButton, ComboboxOptions, ComboboxOption } from '@headlessui/react'
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType, SelectOption } from '../form-types'
import { ClientOnly } from '../utils/client-only'
import './select-field-style.css'
import { Controller } from 'react-hook-form'

export function SelectField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.Select } | { type: FormFieldType.EnumSelect }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  // Support both Select and EnumSelect
  let options: SelectOption[] = []
  if (field.type === FormFieldType.Select) {
    options = field.options.options || []
  } else if (field.type === FormFieldType.EnumSelect) {
    options = Object.keys(field.options.enum || {}).map((key) => ({ label: key, value: key }))
  }
  const defaultValue = options.find((o) => o.value === field.options.defaultValue) || null
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key);
  const selectedOption = options.find((o) => o.value === value) || null;

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          type="text"
          className={clsx('w-full bg-white border border-gray-300 rounded-md shadow-sm py-2 pl-3 pr-10', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={selectedOption?.label || ''}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{selectedOption?.label || '—'}</div>
    );
  }

  return (
    <ClientOnly fallback={<div className="h-10 w-full rounded-md border border-gray-300 bg-gray-100" />}> 
      <Controller
        name={field.key}
        control={form.control}
        defaultValue={defaultValue?.value ?? null}
        render={({ field: { onChange, value } }) => (
          <Combobox
            value={options.find(o => o.value === value) ?? null}
            onChange={(selected: SelectOption | null) => onChange(selected?.value ?? null)}
            disabled={field.options.disabled}
          >
            <div className="relative">
              <ComboboxInput
                className={clsx(
                  'w-full bg-white border border-gray-300 rounded-md shadow-sm py-2 pl-3 pr-10',
                  hasError && '!border-red-600 !focus:border-red-600',
                  field.options.disabled && 'bg-gray-100 cursor-not-allowed',
                )}
                displayValue={(option: SelectOption | null) => option?.label ?? ''}
                placeholder={field.options.label}
                disabled={field.options.disabled}
              />
              <ComboboxButton className="absolute inset-y-0 right-0 flex items-center pr-2">
                <svg className="h-5 w-5 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                  <path
                    fillRule="evenodd"
                    d="M10 3a.75.75 0 01.53.22l3.5 3.5a.75.75 0 01-1.06 1.06L10 4.81 6.53 8.28a.75.75 0 01-1.06-1.06l3.5-3.5A.75.75 0 0110 3zm-3.72 9.28a.75.75 0 011.06 0L10 15.19l3.47-3.47a.75.75 0 111.06 1.06l-4 4a.75.75 0 01-1.06 0l-4-4a.75.75 0 010-1.06z"
                    clipRule="evenodd"
                  />
                </svg>
              </ComboboxButton>
            </div>
            <ComboboxOptions className="absolute z-10 mt-1 w-full bg-white shadow-lg max-h-60 rounded-md py-1 text-base ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none sm:text-sm">
              {options.map((option) => (
                <ComboboxOption
                  key={option.value}
                  value={option}
                  className={({ active }) =>
                    clsx(
                      'cursor-pointer select-none relative py-2 pl-10 pr-4',
                      active ? 'bg-orange-100 text-orange-900' : 'text-gray-900'
                    )
                  }
                >
                  {({ selected }) => (
                    <>
                      <span className={clsx('block truncate', selected ? 'font-medium' : 'font-normal')}>
                        {option.label}
                      </span>
                      {selected ? (
                        <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-orange-600">
                          <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" />
                          </svg>
                        </span>
                      ) : null}
                    </>
                  )}
                </ComboboxOption>
              ))}
            </ComboboxOptions>
          </Combobox>
        )}
      />
    </ClientOnly>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/switch-field.tsx
import { Label, Switch, SwitchGroup } from '@headlessui/react'
import clsx from 'clsx'
import { Controller } from 'react-hook-form'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'

export function SwitchField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.Switch }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key);

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <SwitchGroup as="div" key={field.key} className="flex items-center justify-between">
          <Label as="span" className="ml-3">
            <span className="text-md text-grey_web">{field.options.label}</span>
          </Label>
          <Switch
            checked={value}
            disabled={true}
            className={clsx(
              value ? 'bg-green_web' : 'bg-gray-200',
              'relative inline-flex flex-shrink-0 h-6 w-11 border-2 border-transparent rounded-full',
              'cursor-not-allowed',
            )}
          >
            <span
              aria-hidden="true"
              className={clsx(
                value ? 'translate-x-5' : 'translate-x-0',
                'pointer-events-none inline-block h-5 w-5 rounded-full bg-white shadow transform ring-0 transition ease-in-out duration-200',
              )}
            />
          </Switch>
        </SwitchGroup>
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value ? 'On' : 'Off'}</div>
    );
  }

  return (
    <SwitchGroup as="div" key={field.key} className="flex items-center justify-between">
      <Label as="span" className="ml-3">
        <span className="text-md text-grey_web">{field.options.label}</span>
      </Label>
      <Controller
        key={field.key}
        disabled={field.options.disabled}
        control={form.control}
        name={field.key}
        defaultValue={field.options.defaultValue}
        render={({ field: { onChange, value } }) => (
          <Switch
            {...form.register(field.key, { required: field.options.required })}
            checked={value}
            onChange={onChange}
            className={clsx(
              value ? 'bg-green_web' : 'bg-gray-200',
              'relative inline-flex flex-shrink-0 h-6 w-11 border-2 border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green_web',
              hasError && '!border-red-600 !focus:border-red-600',
            )}
          >
            <span
              aria-hidden="true"
              className={clsx(
                value ? 'translate-x-5' : 'translate-x-0',
                'pointer-events-none inline-block h-5 w-5 rounded-full bg-white shadow transform ring-0 transition ease-in-out duration-200',
              )}
            />
          </Switch>
        )}
      />
    </SwitchGroup>
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/text-field.tsx
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'
import { inputStyle } from '../styles/input-style'

export function TextField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.Input }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="text"
          className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value || '—'}</div>
    );
  }

  return (
    <input
      id={field.key}
      type="text"
      disabled={field.options.disabled}
      autoComplete="true"
      placeholder={field.options.placeholder}
      defaultValue={field.options.defaultValue}
      {...form.register(field.key, { required: field.options.required })}
      className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/textarea-field.tsx
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'
import { inputStyle } from '../styles/input-style'

export function TextAreaField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.TextArea }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <textarea
          rows={field.options.rows ?? 4}
          id={field.key}
          className={clsx(inputStyle, 'block w-full resize-none', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700 whitespace-pre-line">{value || '—'}</div>
    );
  }

  return (
    <textarea
      rows={field.options.rows ?? 4}
      id={field.key}
      disabled={field.options.disabled}
      placeholder={field.options.placeholder}
      defaultValue={field.options.defaultValue}
      className={clsx(inputStyle, 'block w-full resize-none', hasError && '!border-red-600 !focus:border-red-600')}
      {...form.register(field.key, { required: field.options.required })}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/timepicker-field.tsx
import clsx from 'clsx'
import { FormFieldProps, FormFieldType, BaseFieldOptions } from '../form-types'

interface TimePickerFieldType {
  key: string
  type: FormFieldType.TimePicker
  options: BaseFieldOptions
}

export function TimePickerField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<TimePickerFieldType> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="time"
          className={clsx('text-green_web focus:ring-green_web border-gray-300 rounded', hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value || '—'}</div>
    );
  }

  return (
    <input
      id={field.key}
      type="time"
      disabled={field.options.disabled}
      defaultValue={field.options.defaultValue}
      {...form.register(field.key, {
        required: field.options.required,
        //   setValueAs: (v) => v?.split?.('T')[1],
      })}
      className={clsx('text-green_web focus:ring-green_web border-gray-300 rounded', hasError && '!border-red-600 !focus:border-red-600')}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/fields/url-field.tsx
import clsx from 'clsx'
import { FormField, FormFieldProps, FormFieldType } from '../form-types'
import { inputStyle } from '../styles/input-style'

export function UrlField({ form, field, hasError, formReadOnly = false, formReadOnlyStyle = 'value' }: FormFieldProps<Extract<FormField, { type: FormFieldType.Url }>> & { formReadOnly?: boolean, formReadOnlyStyle?: 'value' | 'disabled' }) {
  const isReadOnly = field.options.readOnly ?? formReadOnly;
  const readOnlyStyle = field.options.readOnlyStyle ?? formReadOnlyStyle;
  const value = form.getValues(field.key) ?? '';

  if (isReadOnly) {
    if (readOnlyStyle === 'disabled') {
      return (
        <input
          id={field.key}
          type="url"
          className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
          disabled={true}
          value={value}
        />
      );
    }
    // Render as plain value
    return (
      <div className="min-h-[2.5rem] flex items-center px-3 text-gray-700">{value || '—'}</div>
    );
  }

  return (
    <input
      id={field.key}
      type="url"
      disabled={field.options.disabled}
      placeholder={field.options.placeholder}
      defaultValue={field.options.defaultValue}
      {...form.register(field.key, { required: field.options.required })}
      className={clsx(inputStyle, hasError && '!border-red-600 !focus:border-red-600')}
    />
  )
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/styles/input-style.ts
// /src/lib/styles/input-style.ts
export const inputStyle =
  'appearance-none block w-full px-3 py-2 sm:text-sm border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 disabled:opacity-50 disabled:bg-gray-100'


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/utils/client-only.tsx
import { useEffect, useState, ReactNode } from 'react'

interface ClientOnlyProps {
  children: ReactNode
  fallback?: ReactNode
}

export function ClientOnly({ children, fallback = null }: ClientOnlyProps) {
  const [isClient, setIsClient] = useState(false)

  useEffect(() => {
    setIsClient(true)
  }, [])

  return isClient ? <>{children}</> : <>{fallback}</>
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/utils/date-time.ts
import dayjs from 'dayjs'

export function getDateFromDateTime(yourDate: string) {
  if (!yourDate) return null
  return yourDate.split('T')[0]
}
export function formatDateFromDateTime(yourDate: string, shortDate?: boolean) {
  if (!yourDate) return null
  return dayjs(getDateFromDateTime(yourDate)).format(shortDate ? 'MM/DD/YYYY' : 'MMMM DD, YYYY')
}


// /Users/justinhandley/IdeaProjects/nestled/forms/src/lib/utils/debounce.ts
import { useEffect, useState } from 'react'

export function useDebounce<T>(value: T, delay = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(timer)
    }
  }, [value, delay])

  return debouncedValue
}


